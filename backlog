* release source tarballs via webserver
include the everarch source in the tarball. sign the tarball and place
tarball + signature onto a webserver like evr.ma300k.de
* make sure evr signal handlers only use sig_atomic_t
i assume that there are currently some int's used instead of sig_atomic_t.

some background on this topic is avaliable via
https://beej.us/guide/bgipc/html/
* implement evr-seed-index
evr-seed-index should watch an evr-glacier-storage and index all the
found claims. there should be an http API for retrieving all claims
for one seed. there should be a websocket API for watching updates to
certain seeds.
* support alternative embedding models provided by ollama
https://ollama.com/blog/embedding-models
* visualize embeddings built by embbd
https://www.tensorflow.org/tensorboard/tensorboard_projector_plugin
* enforce authorization token in evr-web's evr-glacier-fs nginx location
* centralize gpg --import-ownertrust
the entrypoint.sh files contain some calls to gpg --import-ownertrust
which could be centralized.

also the possible paths to import gpg keys from can be centralized.
* move dynamically built config files out of /data
so that these files are generated when the container is build. maybe
we can event get rid of the one or other volume. like the /data volume
from evr-web?
* implement a evr-thumbnail-httpd server
it should retrieve refs that point to file claims. a thumbnail for the
given image should be generated.
* attr-index-explorer should show thumbnails for image seeds
* add drop support in evr-web upload app
should allow dropping files in and show the current uploads in a list
* evr-web must not allow requests to other domains
for security reasons.
* cache up to N megabytes of thumbnails in evr-thumbnail-httpd
* document and migrate evr-home-edition to docker images
right now the evr-home-edition docker-compose.yml points to localhost
images. these should be replaces with pointers to
docker.io/ma300k. also the everarch docker images should be uploaded.

also the evr-home-edition docker-compose.yml should contain a short
description how to use the file with docker-compose and how to open
everarch with it.
* install lex and yacc in evr-attr-index podman build image
because right no it's only building because we copy the files
generated by flex and bison into the podman instance.
* add integration test for evr-upload-httpd
one of the integration tests which starts an evr-glacier-storage
should also add a file via the evr-upload-httpd server.
* add integration test for evr-parallel
the tests could check that all commands are killed if another command
fails.
* add integration test for finally application
* get rid of mandatory sqlite dependency
there is the probably weird situation that we want to just build evr
and evr-upload-httpd. these two don't need the sqlite dependency. so
the build for them should be possible without sqlite.

right now the evr-upload-httpd podman Containerfile adds sqlite during
the build. that dependency can be omitted after the change.
* attr-index-explorer should watch evr-attr-index
and refresh shown seeds on changes
* evr cli's evr_cli_get_file(…) should use evr_fetch_file_claim(…) :cligetfile:
* applications should print their config lookup parts in usage
executing any of the evr applications which loads configuration from
files should print the lookup paths when invoked with the --help
argument.
* evr-attr-index should resume building new index
instead of just switching to the new index and continue building
it. serving the old index until the new one is completely indexed will
make index changes much more stable.

right now the folllowing appears from time to time. a new index
generation starts and might take halve a day. during that indexing
evr-attr-index crashes an is restarted by systemd. now the new index
is used which is only partly filled.
* replace select with poll or epoll
because of possible deadlocks in the way evr uses select it's usage
should be replaced with either poll or epoll. for details about
possible select issues in evr see
https://man7.org/linux/man-pages/man2/select.2.html#BUGS

i'm pretty sure that evr is at least vulnerable against the following
section from the select manpage:

#+BEGIN_SRC
       On Linux, select() may report a socket file descriptor as "ready
       for reading", while nevertheless a subsequent read blocks.  This
       could for example happen when data has arrived but upon
       examination has the wrong checksum and is discarded.  There may
       be other circumstances in which a file descriptor is spuriously
       reported as ready.  Thus it may be safer to use O_NONBLOCK on
       sockets that should not block.
#+END_SRC
* replace sscanf calls with strto*
as there is some undefined behavior involved with overflowing numbers
and scanf.

https://port70.net/~nsz/c/c11/n1570.html#7.21.6.2p10

hint came from pitrp.
* perform apk upgrade during podman image building
right now only the index is update but no updated packages are being
installed
* add the Z flag to the podman volumes where applicable
* reenable performance profiling of integration tests
the execution of the integration tests has been moved from test.sh to
the Makefiles generated by automake. in the past test.sh wrote a log
of the complete integration test run into ${script_dir}/test.log. then
in the end it summarized the results from that log with the follwing
commend:

#+BEGIN_SRC shell
"${script_dir}/etc/profile-aggregate/profile-aggregate.py" < "${script_dir}/test.log"
cat "testing/suite/put-parallel/glacier-benchmark.log"
#+END_SRC

the summarization has been removed as no test.log exists anymore. the
summarization should be enabled again.
* evr-file virtual file system for random access to files from storage
right now an attr factory could use ffmpeg to analyze the
files. streaming the video files via evr cli into ffmpeg is possible
but might stream much more data than actually needed to analyze the
video file. there should be a way for applications to have random
access on evr files.

in order to achive that a new everarch application should be
implemented. another virtual file system like evr-fs called
evr-file. evr-file should expect one or more claim refs pointing to
evr file claims. these files should be presented in the evr-file
virtual file system. the file names should be the claim refs.
* valgrind fails when executing unit tests in alpine environment
* op - not applied in evr-attr-index                                    :bug:
the evr-attr-index sqlite db contains the following attributes for the
affected seed. the valid_from and valid_until dates where simplified
to be more simple to read.

#+BEGIN_SRC
sqlite> select key, val_str, valid_from, valid_until, trunc from attr where seed = x'08662E524D0F03C366AEBE368679DCFC6CFB758FA59FFB988DAF36C60000' and key = 'presenter' order by valid_from ;
+-----------+----------------+------------+-------------+-------+
|    key    |    val_str     | valid_from | valid_until | trunc |
+-----------+----------------+------------+-------------+-------+
| presenter | Johne Campbell | 1          | 3           | 0     |
| presenter | John Campbell  | 2          | 3           | 0     |
| presenter | Johne Campbell | 3          | 4           | 1     |
| presenter | Johne Campbell | 4          | 5           | 1     |
| presenter | John Campbell  | 4          |             | 0     |
| presenter | Johne Campbell | 5          |             | 1     |
+-----------+----------------+------------+-------------+-------+
#+END_SRC

the original claim or claim xslt transformation seem not to be the
issue because the transformed claim contains the op -:

#+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8"?>
<evr:claim-set xmlns:evr="https://evr.ma300k.de/claims/" xmlns:dc="http://purl.org/dc/terms/" xmlns:ani="https://ma300k.de/animations/claims/" dc:created="2023-02-23T19:49:19.154000Z">
  <evr:attr index-seed="0" seed="sha3-224-08662e524d0f03c366aebe368679dcfc6cfb758fa59ffb988daf36c6-0000">
    <evr:a op="+" k="class" v="talk"/>
    <evr:a op="-" k="presenter" v="Johne Campbell"/>
  </evr:attr>
  <evr:attr index-seed="1" seed="sha3-224-08662e524d0f03c366aebe368679dcfc6cfb758fa59ffb988daf36c6-0000">
    <evr:a op="=" k="review" v="done"/>
  </evr:attr>
</evr:claim-set>
#+END_SRC

the transformed claim was produced by the following command:

#+BEGIN_SRC
evr get-verify sha3-224-5f47a85240ec6fc2fd63129c120b7d256287d1380c99a46fae047190 | xsltproc animation.xslt - | xmllint --format -
#+END_SRC

the evr_merge_attr_index_attr_* functions seem to not fully support
remove operations. the merge functions may differentiate between the
following merge situations: set, add, rm x, rm all

these operations may be applied to the following example rows from the
attr table:

|-------+------------+-------------+--------------+-------------+------------|
| value | valid_from | valid_until | trunc_before | trunc_after | created by |
|-------+------------+-------------+--------------+-------------+------------|
| v0    |          0 |             |            1 |             | set        |
| v1    |          0 |             |            0 |             | add        |
|       |            |          10 |              |           1 | rm all     |
| v2    |            |          10 |              |           0 | rm x       |
| v0    |          0 |          10 |            1 |           0 | set + rm x |
|-------+------------+-------------+--------------+-------------+------------|

here's an overview what needs to be done in each situation:

** TODO set
existing index attrs starting in the past:
  update valid_until
removed index attrs starting in the past with same value:
  update valid_from and trunc
** TODO add
existing index attrs starting in the past with same value:
  update valid_until
** TODO rm x
** TODO rm all
* evr-fs crash on modifying open file                                   :bug:
evr-fs crashed with the following log message:

#+BEGIN_SRC
2023-07-02T21:32:09 fP Unexpected inode type 1 on release
#+END_SRC

a video stream was started and paused before the crash. after pausing
the steam a modification was performed on the file. then the stream
was resumed.
* evr-fs unable to connect to glacier                                   :bug:
from the evr-fs log
#+BEGIN_SRC
2023-03-07T21:36:56 fE Unable to connect to localhost:2561
2023-03-07T21:36:56 fE Failed to connect to evr-glacier-storage server localhost:2561
2023-03-07T21:36:56 fE Unable to connect to glacier when opening file with inode 2015
2023-03-07T21:39:05 fE Unable to connect to localhost:2561
2023-03-07T21:39:05 fE Failed to connect to evr-glacier-storage server localhost:2561
2023-03-07T21:39:05 fE Unable to connect to glacier when opening file with inode 2149
2023-03-07T21:39:07 fE Unable to connect to localhost:2561
2023-03-07T21:39:07 fE Failed to connect to evr-glacier-storage server localhost:2561
2023-03-07T21:39:07 fE Unable to connect to glacier when opening file with inode 2129
2023-03-07T21:40:10 fE Unable to connect to localhost:2561
2023-03-07T21:40:10 fE Failed to connect to evr-glacier-storage server localhost:2561
2023-03-07T21:40:10 fE Unable to connect to glacier when opening file with inode 2129
2023-03-07T21:40:43 fE Unable to connect to localhost:2561
2023-03-07T21:40:43 fE Failed to connect to evr-glacier-storage server localhost:2561
2023-03-07T21:40:43 fE Unable to connect to glacier when opening file with inode 2927
2023-03-07T21:44:40 fE Unable to connect to localhost:2561
2023-03-07T21:44:40 fE Failed to connect to evr-glacier-storage server localhost:2561
#+END_SRC

evr-fs should log the reason why the connection to evr-glacier-storage
failed.

evr-glacier-storage should log when it rejects a connection and the
reason why it did so.
* parallel evr-fs inode building
right now evr-fs builds the inodes sequentially one seed by another.

building inodes should be performed in parallel in n threads. n should
probably be something like 4 so we don't open too many connections
towards evr-attr-index.
* validate random blobs every 24 hours
so that basic sanity checks on servers with seldom reboots won't
happend seldom.

probably we should trigger the random blob validation via a command
sent to evr-glacier-storage. that way admins can set up a cron to
perform the check at a pleasant time. also checks can be triggered
manually on demand.
* check claim-set created date against key expiry                  :security:
right now evr_is_signature_accepted(…) accepts valid and expired keys
as valid signatures. this is the case because a claim could have been
signed when the key was still valid.

with this task the validation of claim-sets should be extended. if the
claim was signed with an expired key the claim-set's created date must
be before the expiry date of the key.
* check claim-set created date against key revocation              :security:
right now evr_is_signature_accepted(…) will not accept signatures by
revoked keys as valid.

with this task the revocation timestamp should be checked against the
claim-set's created timestamp. claim-sets created before the
revocation timestamp should be valid.
* evr cli should validate put claim sets before upload
validate claims with [[https://relaxng.org/#validators][relax ng]] before putting them into
evr-glacier-storage.

validation rules must be stored with the attr-spec claim. that way the
index defines potential claims it should accept.

evr cli right now provides the sign-put command for uploading
claims. a caller must manually identify a claim by setting the flags
to 1. a new command put-claim must be added to evr cli. put-claim
should fetch the current active index from evr-attr-index, load the
rng grammar from the index's attr-spec and validade the put xml. after
successful validation the same steps as with sign-put must be
performed.

an example attr-spec might look like this:
#+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8"?>
<claim-set
    xmlns="https://evr.ma300k.de/claims/"
    xmlns:dc="http://purl.org/dc/terms/"
    dc:created="1970-01-01T00:00:07.000000Z"
    >
  <attr-spec>
    <attr-def k="tag" type="str"/>
    <transformation type="xslt" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
    <schema type="rng">
        <grammar xmlns="http://relaxng.org/ns/structure/1.0">
            <!-- a rng grammar definition -->
        </grammar>
    </schema>
  </attr-spec>
</claim-set>
#+END_SRC

the doc/claims/attr-spec.xml example must be updatet to show an
example schema.

the put-claim command must set the evr cli flags argument implicitly
to 1. if the flags have been explicitly set to a value unequal to 1
the put-claim command must fail.

xml validation practically can't be executed in evr-glacier-storage
because the relax ng spec would need to be universal for at least all
past claims.
* add get-rnc command to evr cli
evr-attr-index in queried for the current active index. the attr-spec
is fetched for that index from evr-glacier-storage. the rng grammar is
extracted from the attr-spec if it exists. the rng grammar is
converted into a rnc grammar. the rng grammar is cached using the
index ref as file name. the rnc grammar is piped to stdout.

the rng to rnc conversion can probably be performed using
[[https://github.com/oleg-pavliv/emacs/blob/master/xsl/RngToRnc-1_4/RngToRncText.xsl][RngToRncText.xsl from oleg-pavliv]].
* evr emacs mode should load attr-spec rng validation
the minor mode evr-claim-set-mode must load the rng and load it for
the current buffer. this involves the following steps.

get the rnc via get-rnc into a buffer. parse the rnc from that buffer
and apply it to the current buffer.

the emacs lisp function rng-set-schema-file-1 shows how to load a rnc
schema and activate it for the current file. the function
rng-c-parse-file shows how to load rnc content into a buffer and parse
it.
* evr-fs should recreate inodes on evr-attr-index current index change
right now only seed changes are applied to the inode set. if the index
ref changes the whole inode set must be rebuilt.
* document evr-fs in evr.texi
especially the seed-description xml format and the efs:file-set xml
format.
* add has key operator to attr query language
extend the attr query language to support searching for claims which
have a certain key.

not sure yet about the syntax:
#+BEGIN_SRC
tag=todo && some-key
tag=todo && some-key=*
has(some-key) // might clash with 'match functions' comming later
some-key!
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
!(tag=B || tag=C)
#+END_SRC

mapping the first example to sql would be quite easy because we could
do "c.seed not in (…)". but how to map the braces part i'm not sure
yet.
* support xsl:import with blob ref in xslt
evr uses xslt stylesheets when transforming claims in evr-attr-index
and when producing file metadata in evr-fs.

both places should support xsl:import statements so that stylesheets
can be structured. the xsl:import statements should be able to
reference blobs.
* glacier client must update flags in storage if necessary          :gcflgup:
right now the blob flags are untouched if the blob already
exists. this situation can actually happend if a user by accident
uploads a claim and misses the flags command line argument with evr
cli. if the user retries the upload with flags they will not be set.
* show in emacs if query is still running :emacs:
evr-attr-index commands like defun evr-attr-index-search-from-buffer
don't indicate wether they are still running or completed.

the user should be informed if the command completed. either by
showing a status like the emacs compile command or maybe a final line
in the buffer.
* evr sync should utilize the blob's last modified timestamp
right now evr sync walks through all blob refs and compares them
inbetween two evr-glacier-storage instances.

evr sync should have an optional state argument. when called with the
state argument evr cli should try to read a loast modified timestamp
from that state file. the sync should query only blob refs from the
two storages which appeared at or after the last modified timestamp.

this should speed up sync a lot for huge repositories. despite we will
loose some automatic restoration of blobs which got lost due to bit
flips in the buckets.
* migrate to partial evr-fs readdir buffer rebuilds
right now evr_fs_readdir in evr-fs.c builds the complete readdir
buffer only to report a slice of at an the end.

the off parameter should be used to communicate which inodes should
be read. probably the off parameter should be the directory child's
index from struct evr_fs_inode_dir.
* evr-fs integration test which restarts evr-glacier-storage
evr-fs should work just like before the restart. restart should maybe
occur while a file within evr-fs is open.
* improve query error messages if at least bison 3.6 is available
bison before 3.6 does not support "%define parse.error
detailed". that's why everarch right now uses the value "verbose".

the configure script should detect the bison version and use
"detailed" if at least bison 3.6 is available.
* open bucket file descriptor constant for uninitialized
glacier opens bucket files in a lazy way. the value for identifiying a
not yet opened bucket file should be a constant instead of just -1.
* add i18n support in attr query contains operator
right now sqlite is used for comparing values when using the attr
query contains (~) operator in a case insensitive way. the lower case
operation works only on ASCII characters. in order to get utf-8 lower
case conversion support the [[https://github.com/sqlite/sqlite/tree/master/ext/icu][sqlite ICU extension]] must be loaded.

test if this extension is part of the sqlite3 debian packaging. load
it gracefully. log info if it can't be loaded and continue.
* create bucket directory if not existing :bdircre:
* auto generate ssl cert and key if they don't exists
use some command like written in tls.txt
* add handling of too small bucket files
a bucket file which is smaller than the bucket file header of 4 bytes
should be recreated.
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* plan graph query approach
[[https://en.wikipedia.org/wiki/SPARQL][sparql]] queryability can be achieved via [[https://librdf.org/][librdf]] which stores data in
RDF. query output can be formatted with [[https://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321/][sparql xml results]].

we probably want to become a [[https://www.w3.org/wiki/SparqlEndpoints][SPARQL endpoint]]. despite this means we
need http support. SPARQL http access is described in [[https://www.w3.org/TR/2013/REC-sparql11-http-rdf-update-20130321/][SPARQL 1.1 Graph
Store HTTP Protocol]].
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* parallel evr-attr-index claim-set preparation
indexing a claim-set can be splitted into two phases. a first phase
which fetches the claim-set XML, then applies the attr factories and
XSLT stylesheet on it. then a second phase which persists the attr and
archive claims into the index.

the first phase should be executed in parallel.

the solution might involve a ring buffer which n slots. each slot
holds one to be prepared claim-set. the slots in the ring buffer have
the states queued and prepared. there are n threads which fetch the
next queued slot and prepare it.
* ---- v0.2 boundary ----
everything above will be part of the second major release of everarch.

the vision of the second release is: let's go web
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC

the open question is how to define what the match functions are
actually doing. for example which mime types are treated as
image. this should not be coded into everarch. it would be nice to be
able to define them somehow in blobs.
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* user PRI macros in format strings for integers
right now many places use for example %d or %ld for printing integers
with defined sizes like int64_t. the PRI* macros from [[https://cplusplus.com/reference/cinttypes/][inttypes.h]]
should be used instead. this should guarantee compatibility for other
platforms.
* use $XDG_CONFIG_HOME to lookup configuration directory
XDG_* is defined by the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][basedir-spec]].
* replace struct chunk_set with struct evr_llbuf_s
child_size could be 1 and block_child_count may be 1MB.

especially because struct chunk_set is not very well fitted for
growing because of the evr_chunk_set_max_chunks limitation.

there should also be a function for writing linked lists to a file
descriptor using writev.
** TODO struct evr_auth_token_cfg should use the linked list
** TODO struct evr_cert_cfg should use the linked list
* rename struct dynamic_array to evr_rabuf
dny-mem.h should provide one growable random access data structure.

struct dynamic_array should be renamed to hint the random access
usage. maybe evr_rabuf instead of dynamic_array.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.
* keep bucket file sizes below RLIMIT_FSIZE
bucket file sizes shold be below RLIMIT_FSIZE. see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for
retrieving RLIMIT_FSIZE and limit the bucket size regarding to
it. also the chunk size should not grow over the configured limit.
* switch to mmap/msync for writing bucket files
and measure the io performance compared to open and fsync.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* switch to io_uring for network io
* use readv and writev in struct evr_file
right how read and write operations use via evr_file implement thea
read/write interface with one buffer.

struct evr_file should implement the readv and writev interface to
reduce the number of system calls needed.

the struct evr_file read and write functions should be removed. caller
code should be adjusted.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.

i guess the basis for this task is no longer existent because we
switched to sqlite's WAL mode.
