* deadlock when opening many files via evr-fs :bug:
opening and closing many files leads do a deadlock.

evr-fs output filtered just for the open and release logs:
#+BEGIN_SRC
2022-12-13T20:08:10 fD fuse open inode 53
2022-12-13T20:08:11 fD fuse release file handle 0 for inode 53
2022-12-13T20:08:12 fD fuse open inode 91
2022-12-13T20:08:13 fD fuse release file handle 1 for inode 91
2022-12-13T20:08:13 fD fuse open inode 90
2022-12-13T20:08:15 fD fuse release file handle 2 for inode 90
2022-12-13T20:08:15 fD fuse open inode 89
2022-12-13T20:08:15 fD fuse release file handle 3 for inode 89
2022-12-13T20:08:16 fD fuse open inode 88
2022-12-13T20:08:17 fD fuse release file handle 4 for inode 88
2022-12-13T20:08:17 fD fuse open inode 87
2022-12-13T20:08:18 fD fuse release file handle 5 for inode 87
2022-12-13T20:08:18 fD fuse open inode 86
2022-12-13T20:08:19 fD fuse release file handle 6 for inode 86
2022-12-13T20:08:20 fD fuse open inode 85
2022-12-13T20:08:21 fD fuse release file handle 7 for inode 85
2022-12-13T20:08:21 fD fuse open inode 84
2022-12-13T20:08:21 fD fuse release file handle 8 for inode 84
2022-12-13T20:08:22 fD fuse open inode 83
2022-12-13T20:08:23 fD fuse release file handle 9 for inode 83
2022-12-13T20:08:24 fD fuse open inode 82
2022-12-13T20:08:24 fD fuse open inode 61
2022-12-13T20:08:24 fD fuse release file handle 10 for inode 82
2022-12-13T20:08:31 fD fuse release file handle 11 for inode 61
2022-12-13T20:08:31 fD fuse open inode 79
#+END_SRC

successful open of inode 83
#+BEGIN_SRC
2022-12-13T20:08:22 fD fuse open inode 83
2022-12-13T20:08:22 fD Use SSL cert /home/animation/.config/everarch/evr-glacier-storage-cert.pem for localhost:2561
2022-12-13T20:08:22 fD Sending get sha3-224-edef8c2df3e1d13bd351ae697f31bc4f31ae6a4ef4a738f6118b2603 command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 69828
2022-12-13T20:08:22 fD fuse read 32768 bytes from file handle 9 on inode 83 at offset 0
2022-12-13T20:08:22 fD Sending get sha3-224-e4e36b921d7068286842d93bb03b4356ac50e1a6424c59a397a6d22b command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 118637
2022-12-13T20:08:22 fD Read 32768 bytes at offset 0 from slice 0
2022-12-13T20:08:22 fD fuse read 8192 bytes from file handle 9 on inode 83 at offset 228974592
2022-12-13T20:08:22 fD Sending get sha3-224-bd1fce03752372244eb2aecdcb2ab0988df370103b82b74c2c17b0d4 command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 591592
2022-12-13T20:08:22 fD Read 8192 bytes at offset 147038 from slice 701
2022-12-13T20:08:22 fD fuse read 32768 bytes from file handle 9 on inode 83 at offset 228982784
2022-12-13T20:08:22 fD Read 32768 bytes at offset 155230 from slice 701
2022-12-13T20:08:22 fD fuse read 131072 bytes from file handle 9 on inode 83 at offset 229015552
2022-12-13T20:08:22 fD Read 131072 bytes at offset 187998 from slice 701
2022-12-13T20:08:22 fD fuse read 131072 bytes from file handle 9 on inode 83 at offset 229146624
2022-12-13T20:08:22 fD Read 131072 bytes at offset 319070 from slice 701
2022-12-13T20:08:22 fD fuse read 131072 bytes from file handle 9 on inode 83 at offset 229277696
2022-12-13T20:08:22 fD Read 131072 bytes at offset 450142 from slice 701
2022-12-13T20:08:22 fD fuse read 131072 bytes from file handle 9 on inode 83 at offset 229408768
2022-12-13T20:08:22 fD Read 10377 bytes at offset 581214 from slice 701
2022-12-13T20:08:22 fD Sending get sha3-224-f16b06ad790cdac4a7e32cad1b222a58ad4a050f058f5a2b86bc2421 command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 322176
2022-12-13T20:08:22 fD Read 120695 bytes at offset 0 from slice 702
2022-12-13T20:08:22 fD fuse read 131072 bytes from file handle 9 on inode 83 at offset 229539840
2022-12-13T20:08:22 fD Read 131072 bytes at offset 120695 from slice 702
2022-12-13T20:08:22 fD fuse read 73728 bytes from file handle 9 on inode 83 at offset 229670912
2022-12-13T20:08:22 fD Read 70408 bytes at offset 251767 from slice 702
2022-12-13T20:08:22 fD fuse read 81920 bytes from file handle 9 on inode 83 at offset 32768
2022-12-13T20:08:22 fD Sending get sha3-224-e4e36b921d7068286842d93bb03b4356ac50e1a6424c59a397a6d22b command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 118637
2022-12-13T20:08:22 fD Read 81920 bytes at offset 32768 from slice 0
2022-12-13T20:08:22 fD fuse read 8192 bytes from file handle 9 on inode 83 at offset 72376320
2022-12-13T20:08:22 fD Sending get sha3-224-77845935078af9eae2c1d9d656fd55d263e153b10161fdfc10f0f14e command to server
2022-12-13T20:08:22 fD Storage responded with status code 0x20 and body size 787600
2022-12-13T20:08:23 fD Read 8192 bytes at offset 478931 from slice 233
2022-12-13T20:08:23 fD fuse read 65536 bytes from file handle 9 on inode 83 at offset 72384512
2022-12-13T20:08:23 fD Read 65536 bytes at offset 487123 from slice 233
2022-12-13T20:08:23 fD fuse release file handle 9 for inode 83
#+END_SRC

deadlocked open of inode 79
#+BEGIN_SRC
2022-12-13T20:08:31 fD fuse open inode 79
2022-12-13T20:08:31 fD Use SSL cert /home/animation/.config/everarch/evr-glacier-storage-cert.pem for localhost:2561
2022-12-13T20:08:31 fD Sending get sha3-224-8b9ab810bacc6fd2b59ba79a9272a44330654623a85f3161d7a4c672 command to server
2022-12-13T20:08:31 fD Storage responded with status code 0x20 and body size 69063
#+END_SRC
* evr-fs integration test which restarts evr-attr-index
evr-fs should work just like before the restart.
* evr-fs integration test which restarts evr-glacier-storage
evr-fs should work just like before the restart. restart should maybe
occur while a file within evr-fs is open.
* evr-fs should recreate inodes on evr-attr-index current index change
right now only seed changes are applied to the inode set. if the index
ref changes the whole inode set must be rebuilt.
* reserve .evr in root directory within evr-fs
.evr should always be an empty directory. event if a efs:file mapps to
.evr. it should be like a reserved namespace for future interaction
with evr-fs during runtime.
* document evr-fs in evr.texi
especially the seed-description xml format and the efs:file-set xml
format.
* add has key operator to attr query language
extend the attr query language to support searching for claims which
have a certain key.

not sure yet about the syntax:
#+BEGIN_SRC
tag=todo && some-key
tag=todo && some-key=*
has(some-key) // might clash with 'match functions' comming later
some-key!
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
!(tag=B || tag=C)
#+END_SRC

mapping the first example to sql would be quite easy because we could
do "c.seed not in (…)". but how to map the braces part i'm not sure
yet.
* evr cli should validate put claim sets before upload
validate claims with [[https://relaxng.org/#validators][relax ng]] before putting them into
evr-glacier-storage.

validation should be a evr cli feature which is turned off by
default. user must supply a relax ng spec. still relax ng spec should
be stored in evr-glacier-storage.

xml validation practically can't be executed in evr-glacier-storage
because the relax ng spec would need to be universal for at least all
past claims.
* support xsl:import with blob ref in xslt
evr uses xslt stylesheets when transforming claims in evr-attr-index
and when producing file metadata in evr-fs.

both places should support xsl:import statements so that stylesheets
can be structured. the xsl:import statements should be able to
reference blobs.
* glacier client must update flags in storage if necessary          :gcflgup:
right now the blob flags are untouched if the blob already
exists. this situation can actually happend if a user by accident
uploads a claim and misses the flags command line argument with evr
cli. if the user retries the upload with flags they will not be set.
* show in emacs if query is still running :emacs:
evr-attr-index commands like defun evr-attr-index-search-from-buffer
don't indicate wether they are still running or completed.

the user should be informed if the command completed. either by
showing a status like the emacs compile command or maybe a final line
in the buffer.
* parallel evr-fs inode building
right now evr-fs builds the inodes sequentially one seed by another.

building inodes should be performed in parallel in n threads. n should
probably be something like 4 so we don't open too many connections
towards evr-attr-index.
* evr sync should utilize the blob's last modified timestamp
right now evr sync walks through all blob refs and compares them
inbetween two evr-glacier-storage instances.

evr sync should have an optional state argument. when called with the
state argument evr cli should try to read a loast modified timestamp
from that state file. the sync should query only blob refs from the
two storages which appeared at or after the last modified timestamp.

this should speed up sync a lot for huge repositories. despite we will
loose some automatic restoration of blobs which got lost due to bit
flips in the buckets.
* migrate to partial evr-fs readdir buffer rebuilds
right now evr_fs_readdir in evr-fs.c builds the complete readdir
buffer only to report a slice of at an the end.

the off parameter should be used to communicate which inodes should
be read. probably the off parameter should be the directory child's
index from struct evr_fs_inode_dir.
* improve query error messages if at least bison 3.6 is available
bison before 3.6 does not support "%define parse.error
detailed". that's why everarch right now uses the value "verbose".

the configure script should detect the bison version and use
"detailed" if at least bison 3.6 is available.
* validate random blobs every 24 hours
so that basic sanity checks on servers with seldom reboots won't
happend seldom.
* open bucket file descriptor constant for uninitialized
glacier opens bucket files in a lazy way. the value for identifiying a
not yet opened bucket file should be a constant instead of just -1.
* add i18n support in attr query contains operator
right now sqlite is used for comparing values when using the attr
query contains (~) operator in a case insensitive way. the lower case
operation works only on ASCII characters. in order to get utf-8 lower
case conversion support the [[https://github.com/sqlite/sqlite/tree/master/ext/icu][sqlite ICU extension]] must be loaded.

test if this extension is part of the sqlite3 debian packaging. load
it gracefully. log info if it can't be loaded and continue.
* create bucket directory if not existing :bdircre:
* auto generate ssl cert and key if they don't exists
use some command like written in tls.txt
* add handling of too small bucket files
a bucket file which is smaller than the bucket file header of 4 bytes
should be recreated.
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* evaluate http libraries for C
the evaluation should decide if the evr-web-server is implemented in C
, node.js or maybe deno.
* plan graph query approach
[[https://en.wikipedia.org/wiki/SPARQL][sparql]] queryability can be achieved via [[https://librdf.org/][librdf]] which stores data in
RDF. query output can be formatted with [[https://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321/][sparql xml results]].

we probably want to become a [[https://www.w3.org/wiki/SparqlEndpoints][SPARQL endpoint]]. despite this means we
need http support. SPARQL http access is described in [[https://www.w3.org/TR/2013/REC-sparql11-http-rdf-update-20130321/][SPARQL 1.1 Graph
Store HTTP Protocol]].
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* introduce evr-web-server
should bind to port 443 and respond some hello world as a demo.
* search seed claims endpoint for evr-web-server
GET /seeds?tag=todo
POST /seeds with query in post body?

responds found seed claims as JSON:

#+BEGIN_SRC
[
  {
    "ref": "sha3-224-…",
    "attr": {
      "tag": ["todo"]
    }
  }
]
#+END_SRC
* introduce evr-web-explorer
HTML/CSS/JS application which allows exploring seed claims. should use the evr-web-server API for retrieving 
* evr-web-explorer should show seed claims
query /seeds evr-web-server endpoint and show the seeds as some kind
of list.
* parallel evr-attr-index claim-set preparation
indexing a claim-set can be splitted into two phases. a first phase
which fetches the claim-set XML, then applies the attr factories and
XSLT stylesheet on it. then a second phase which persists the attr and
archive claims into the index.

the first phase should be executed in parallel.

the solution might involve a ring buffer which n slots. each slot
holds one to be prepared claim-set. the slots in the ring buffer have
the states queued and prepared. there are n threads which fetch the
next queued slot and prepare it.
* ---- v0.2 boundary ----
everything above will be part of the second major release of everarch.

the vision of the second release is: let's go web
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC

the open question is how to define what the match functions are
actually doing. for example which mime types are treated as
image. this should not be coded into everarch. it would be nice to be
able to define them somehow in blobs.
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* evr-glacier-storage should notify systemd when ready
the systemd service type notify uses a notification approach provided
by libsystemd-daemon.so so the service can tell systemd it's
ready. this notifications should be performed after
evr-glacier-storage is listening on the socket for incomming
connections.

the configure.ac scripts should detect if systemd support is
available. maybe it the libsystemd-daemos.so or something is
present. if it is not found evr-glacier-storage must be compiled
without any systemd dependency.
* user PRI macros in format strings for integers
right now many places use for example %d or %ld for printing integers
with defined sizes like int64_t. the PRI* macros from [[https://cplusplus.com/reference/cinttypes/][inttypes.h]]
should be used instead. this should guarantee compatibility for other
platforms.
* use $XDG_CONFIG_HOME to lookup configuration directory
XDG_* is defined by the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][basedir-spec]].
* replace struct chunk_set with struct evr_llbuf_s
child_size could be 1 and block_child_count may be 1MB.

especially because struct chunk_set is not very well fitted for
growing because of the evr_chunk_set_max_chunks limitation.

there should also be a function for writing linked lists to a file
descriptor using writev.
** TODO struct evr_auth_token_cfg should use the linked list
** TODO struct evr_cert_cfg should use the linked list
* rename struct dynamic_array to evr_rabuf
dny-mem.h should provide one growable random access data structure.

struct dynamic_array should be renamed to hint the random access
usage. maybe evr_rabuf instead of dynamic_array.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.
* keep bucket file sizes below RLIMIT_FSIZE
bucket file sizes shold be below RLIMIT_FSIZE. see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for
retrieving RLIMIT_FSIZE and limit the bucket size regarding to
it. also the chunk size should not grow over the configured limit.
* switch to mmap/msync for writing bucket files
and measure the io performance compared to open and fsync.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* switch to io_uring for network io
* use readv and writev in struct evr_file
right how read and write operations use via evr_file implement thea
read/write interface with one buffer.

struct evr_file should implement the readv and writev interface to
reduce the number of system calls needed.

the struct evr_file read and write functions should be removed. caller
code should be adjusted.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.

i guess the basis for this task is no longer existent because we
switched to sqlite's WAL mode.
